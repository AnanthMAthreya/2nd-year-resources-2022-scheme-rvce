import matplotlib.pyplot as plt
import numpy as np

# lo=input("enter the poly")

def f(x):
    # return eval(lo)
    return -x**2


def hill_climbing(initial_x, max_iterations=1000, step_size=0.9):
    current_x = initial_x
    iteration = 0
    current_value = f(current_x)

    x_values = [current_x]
    y_values = [f(current_x)]

    while iteration < max_iterations:
        neighbor_x = current_x + step_size * np.random.uniform(-1,1)

        neighbor_value = f(neighbor_x)

        if neighbor_value > current_value:
            current_x = neighbor_x
            current_value = neighbor_value
            x_values.append(current_x)
            y_values.append(current_value)

        iteration += 1

    return current_x, f(current_x), x_values, y_values


initial_x = float(input("Enter the initial value for x: "))

best_solution, best_value, x_values, y_values = hill_climbing(initial_x)

print(f"x = {best_solution}")
print(f"f(x) = {best_value}")

# Generate original function curve
original_x_values = np.linspace(min(x_values), max(x_values), 1000)
original_y_values = [f(x) for x in original_x_values]

# Plot both original function curve and points generated by hill climbing
plt.plot(original_x_values, original_y_values)
plt.plot(x_values, y_values)
plt.title("Hill Climbing Algorithm")
plt.xlabel("x")
plt.ylabel("f(x)")
# plt.legend()
plt.show()